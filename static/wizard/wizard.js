{"cython": {}, "gap": {}, "python": {"Language": {"Tutorial": [["Hello World", ["print \"Hello World\"", "The \"Hello World\" program"]], ["Variables", ["x = 1\ny = x + 1\nprint x\nprint y\n", "A variable is a name for an object. It is done via this syntax:\n``` variablename = object ```\n"]], ["Print Data", ["x = \"Hello\"\ny = 2.123456789\nprint \"%s World, y = %f\" %(x, y)\nprint \"x={x}, y={y:.3f}\".format(**locals())\n", "The \"Hello World\" program printing some values."]], ["Expressions", ["print (5 + 6) * 11\nz = 3\nprint (1 + z)**2\nfrom math import sqrt\nprint sqrt(z)\n", "Expressions are evaluated, they can consist of operators and function calls."]], ["Functions", ["def function1(x, y):\n    z = 10 * x + y\n    return z\n\nprint function1(4, 5)\nprint function1(1,-1)\n", "A function call is one of the most basic levels of abstraction. A common subroutine of evaluations is run with varying initial arguments. The `return` statement is very important: data flows back to where the functions has been called.\n"]], ["Data Structure: List", ["x = [42, \"Hello\", [1,2,3]]\nprint x\nx.append(\"World\")\nprint x\n", "To organize the information in a program, data structures come to help. A very basic one is an ordered collection of arbitrary objects.\n"]], ["Data Structure: Dict(ionary)", ["d = dict()\nd[42] = \"The Answer\"\nd[\"what\"] = [\"this\", \"and\", \"that\"]\nd[(4,2)] = 99\nprint d[(4,2)]\nprint d.keys()\nprint 42 in d", "A dictionary is an mapping of (immutable) objects to arbitrary objects. The immutable objects are called \"keys\" and are most commonly numbers, strings or tuples.\n"]]]}, "Numpy/Scipy": {"Intro": [["Numpy Basics", ["import numpy as np\nprint np, np.__version__\n", "[Numpy](http://docs.scipy.org/) is a library for numerical mathematics.\nIt is usually imported via `import numpy as np`.\n"]]], "Optimization": [["Optimization, 1D, unconstrained", ["import numpy as np\n", "Unconstrained one-dimensional optimization with Scipy."]]]}}, "r": {"Statistics": {"Modeling": [["Linear Model", ["lm(y ~ x)\n", "Linear Model Example"]], ["Nonlinear Model", ["lm(y ~ x)\n", "Nonlinear Model Example"]], ["ANOVA", ["lm1 <- lm(y ~ x)\nanova(lm1)", "ANOVA of a linear model\n"]]]}}, "sage": {"Plotting": {"2D": [["Simple 2D Plot", ["plot(sin, (x, -10, 10))", "Plot of $\\sin$-function."]], ["Cool 2D Plot", ["plot(x * sin(x), (x, -10, 10))", "Plot of $f(x) = x \\sin(x)$."]]], "3D": [["Simple 3D Plot", ["%var x, y\nplot3d(sin(x) * cos(y), (x, -10, 10), (y, -10, 10))\n", "3D plot of the $\\sin(x)\\cos(y)$-function."]]], "Intro": [["Intro", ["plot(x * sin(x), (x, -10, 10))", "This is a very simple example how to plot a function."]]]}, "Tutorial": {"Help": [["Getting Help", ["log2?", "Sage has extensive built-in documentation, accessible by typing the name of a function or a constant (for example), followed by a question mark:\n``` log2? ```\nIt's also possible to use the `help(...)` function.\n", "[Sage Documentation](http://www.sagemath.org/doc/tutorial/)"]]], "Tour": [["Expressions and Assignments", ["a = 5   # giving \"5\" the name \"a\"\na\n2 == 2  # testing if 2 equals 2\n2 == 3\n2 < 4\na == 5  # not an assignment, but a test if a is still 5\n", "The language of Sage is built on top of Python. There are only some minor differences and hence you can apply almost all Python knowledge for working with Sage. Assignments are one of the most basic concepts of programming. An object is born -- as a result of a creation or as an evaluation of an expression -- and assigned to (variable)name for later use. This assignment happens with the `=` sign on the left -- do not get confused with a mathematical equation!\n"]], ["Mathematical Operations", ["2 ** 3\n2^3\n10 % 3\n8 / 7   # this gives a fraction\n9//2    # integer quotient\n", "Sage uses standard operators to express mathematical operations. In contrast to Python, the `^` is for exponentiation!\n"]], ["Mathematical Functions", ["sqrt(9.81)\nsin(6.28)\ncos(pi)\ntan(pi/4)\n", "Many standard functions are directly available. They produce either numerical approximations or give a symbolic expression.\n"]], ["Types", ["a = 5\ntype(a)\na = 9/82\ntype(a)\na = \"I am a string in quotes\"\ntype(a)\n", "A great deal of programming is about organizing data and information. A \"type\" is a specific pattern, how data is organized with descriptive names. Use Pythons `type(...)` function any time, to learn more about what you are currently dealing with.\n"]], ["Classes", ["class Fraction(object):\n    def __init__(self, nom, denom):\n        self.nominator = nom\n        self.denominator = denom\nf1 = Fraction(1, 2)\nf1.nominator\nf1.denominator\n", "A common way to create types are classes. Understanding their construction is not necessary at this point, but mentioned for completeness.\n"]], ["Functions", ["def f1(x):\n    return 2*x\nf1(11)\n\n%var x\nf2(x) = 2 * x\nf2(21)\n", "In Sage, there are (at least) two types of functions. A Python-function is defined via the `def` keyword and maps optional arguments to a returned value. For more information, [consult the Sage Tour](http://www.sagemath.org/doc/tutorial/tour_help.html#functions-indentation-and-counting).\nSymbolic-functions are defined via `f(x) = ...` and hence fulfull a special purpose for symbolic computations.\n"]], ["Symbolic Expressions", ["%var x, y\ntype(y)\nex1 = (x + y)^2 == 1\nex1\nex2 = x - y == 1\nex2\n", "A great deal of mathematics concerns symbolic expressions. The fundamental building block is a single variable, `x`, `y`, etc.. It can be defined via `var('x')` or the magic command `%var y`. Then, symbolic expressions are built using them. It is important to define the variables as being symblic. Otherwise, the constructed expression is something completely different!\n"]], ["Approximate Symbolic Expressions", ["exp(2)\nn(exp(2))\nsin(31.41592).n(digits=50)\nnumerical_approx(pi, prec=200)\n", "To approximate a symbolic expression (without a free variable), use `n(...)`\n"]], ["LaTeX Formulas", ["%var x, y\nex1 = (x + y)^2 == 1\nshow(ex1)\n", "To see a LaTeX rendering of such a symbolic expression, use Sage's `show(...)` function."]], ["Solving Symbolic Equations", ["%var x, y\nsolve(2*x^2 + 1, x)\nex1 = (x + y)^2 - 1\nex2 = x - y == 1\nsolve([ex1, ex2], [x, y])\n", "Sage's `solve(...)` function allows you to solve symbolic equations exactly. Expressons are automatically assumed to be equal to zero.\n"]], ["Numerical Solutions", ["%var phi\nfind_root(cos(phi)==sin(phi), 0, pi/2)\n", "Sage's `find_root(...)` solves equations numerically. The optional second and third argument constrain the variable to this interval.\n"]], ["Symbolic Differentiation", ["%var x, y\nf = sin(x^2) + 17*y^2\ndiff(f, x)\nf.diff(y, 3)\n", "Symbolic expressions can be differentiated. This works either with Sage's `diff(...)` function or the expression's `.diff(...)` method. You can also compute the n-th derivative directly.\n"]], ["Symbolic Integration", ["%var x\nintegral(x*sin(x^2), x)\n", "If possible, the `integral(...)` function computes a symbolic integral.\n"]], ["Tab-Completion", ["%var x\nex = 2*x/sin(x)\nex.\n", "To learn more about possible operations on an object, first type in the variable, then a dot, and then press the `[TAB]` key. The tab key can either autocomplete you current input at the position of the cursor, or give you a list of possible completions.\nIn the given example here, position the cursor after the dot and press the `[TAB]` key.\n"]]]}}}